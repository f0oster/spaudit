// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: items.sql

package db

import (
	"context"
	"database/sql"
)

const getItemByGUID = `-- name: GetItemByGUID :one
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND item_guid = ?2
`

type GetItemByGUIDParams struct {
	SiteID   int64  `json:"site_id"`
	ItemGuid string `json:"item_guid"`
}

type GetItemByGUIDRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) GetItemByGUID(ctx context.Context, arg GetItemByGUIDParams) (GetItemByGUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getItemByGUID, arg.SiteID, arg.ItemGuid)
	var i GetItemByGUIDRow
	err := row.Scan(
		&i.SiteID,
		&i.ItemGuid,
		&i.ListItemGuid,
		&i.ListID,
		&i.ItemID,
		&i.Url,
		&i.IsFile,
		&i.IsFolder,
		&i.HasUnique,
		&i.Name,
		&i.AuditRunID,
	)
	return i, err
}

const getItemByListAndGUID = `-- name: GetItemByListAndGUID :one
SELECT site_id, item_guid, list_item_guid, list_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2 AND item_guid = ?3
`

type GetItemByListAndGUIDParams struct {
	SiteID   int64  `json:"site_id"`
	ListID   string `json:"list_id"`
	ItemGuid string `json:"item_guid"`
}

type GetItemByListAndGUIDRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) GetItemByListAndGUID(ctx context.Context, arg GetItemByListAndGUIDParams) (GetItemByListAndGUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getItemByListAndGUID, arg.SiteID, arg.ListID, arg.ItemGuid)
	var i GetItemByListAndGUIDRow
	err := row.Scan(
		&i.SiteID,
		&i.ItemGuid,
		&i.ListItemGuid,
		&i.ListID,
		&i.Url,
		&i.IsFile,
		&i.IsFolder,
		&i.HasUnique,
		&i.Name,
		&i.AuditRunID,
	)
	return i, err
}

const getItemByListAndID = `-- name: GetItemByListAndID :one
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2 AND item_id = ?3
`

type GetItemByListAndIDParams struct {
	SiteID int64  `json:"site_id"`
	ListID string `json:"list_id"`
	ItemID int64  `json:"item_id"`
}

type GetItemByListAndIDRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) GetItemByListAndID(ctx context.Context, arg GetItemByListAndIDParams) (GetItemByListAndIDRow, error) {
	row := q.db.QueryRowContext(ctx, getItemByListAndID, arg.SiteID, arg.ListID, arg.ItemID)
	var i GetItemByListAndIDRow
	err := row.Scan(
		&i.SiteID,
		&i.ItemGuid,
		&i.ListItemGuid,
		&i.ListID,
		&i.ItemID,
		&i.Url,
		&i.IsFile,
		&i.IsFolder,
		&i.HasUnique,
		&i.Name,
		&i.AuditRunID,
	)
	return i, err
}

const getItemByListItemGUID = `-- name: GetItemByListItemGUID :one
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_item_guid = ?2
`

type GetItemByListItemGUIDParams struct {
	SiteID       int64          `json:"site_id"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
}

type GetItemByListItemGUIDRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) GetItemByListItemGUID(ctx context.Context, arg GetItemByListItemGUIDParams) (GetItemByListItemGUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getItemByListItemGUID, arg.SiteID, arg.ListItemGuid)
	var i GetItemByListItemGUIDRow
	err := row.Scan(
		&i.SiteID,
		&i.ItemGuid,
		&i.ListItemGuid,
		&i.ListID,
		&i.ItemID,
		&i.Url,
		&i.IsFile,
		&i.IsFolder,
		&i.HasUnique,
		&i.Name,
		&i.AuditRunID,
	)
	return i, err
}

const insertItem = `-- name: InsertItem :exec
INSERT INTO items (site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11)
`

type InsertItemParams struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) InsertItem(ctx context.Context, arg InsertItemParams) error {
	_, err := q.db.ExecContext(ctx, insertItem,
		arg.SiteID,
		arg.ItemGuid,
		arg.ListItemGuid,
		arg.ListID,
		arg.ItemID,
		arg.Url,
		arg.IsFile,
		arg.IsFolder,
		arg.HasUnique,
		arg.Name,
		arg.AuditRunID,
	)
	return err
}

const itemsForList = `-- name: ItemsForList :many
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2
ORDER BY item_id
LIMIT ?4 OFFSET ?3
`

type ItemsForListParams struct {
	SiteID int64  `json:"site_id"`
	ListID string `json:"list_id"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ItemsForListRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) ItemsForList(ctx context.Context, arg ItemsForListParams) ([]ItemsForListRow, error) {
	rows, err := q.db.QueryContext(ctx, itemsForList,
		arg.SiteID,
		arg.ListID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsForListRow
	for rows.Next() {
		var i ItemsForListRow
		if err := rows.Scan(
			&i.SiteID,
			&i.ItemGuid,
			&i.ListItemGuid,
			&i.ListID,
			&i.ItemID,
			&i.Url,
			&i.IsFile,
			&i.IsFolder,
			&i.HasUnique,
			&i.Name,
			&i.AuditRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const itemsForListByAuditRun = `-- name: ItemsForListByAuditRun :many
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2 AND audit_run_id = ?3
ORDER BY item_id
LIMIT ?5 OFFSET ?4
`

type ItemsForListByAuditRunParams struct {
	SiteID     int64  `json:"site_id"`
	ListID     string `json:"list_id"`
	AuditRunID int64  `json:"audit_run_id"`
	Offset     int64  `json:"offset"`
	Limit      int64  `json:"limit"`
}

type ItemsForListByAuditRunRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) ItemsForListByAuditRun(ctx context.Context, arg ItemsForListByAuditRunParams) ([]ItemsForListByAuditRunRow, error) {
	rows, err := q.db.QueryContext(ctx, itemsForListByAuditRun,
		arg.SiteID,
		arg.ListID,
		arg.AuditRunID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsForListByAuditRunRow
	for rows.Next() {
		var i ItemsForListByAuditRunRow
		if err := rows.Scan(
			&i.SiteID,
			&i.ItemGuid,
			&i.ListItemGuid,
			&i.ListID,
			&i.ItemID,
			&i.Url,
			&i.IsFile,
			&i.IsFolder,
			&i.HasUnique,
			&i.Name,
			&i.AuditRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const itemsWithUniqueForList = `-- name: ItemsWithUniqueForList :many
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2 AND has_unique = 1
ORDER BY item_id
LIMIT ?4 OFFSET ?3
`

type ItemsWithUniqueForListParams struct {
	SiteID int64  `json:"site_id"`
	ListID string `json:"list_id"`
	Offset int64  `json:"offset"`
	Limit  int64  `json:"limit"`
}

type ItemsWithUniqueForListRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) ItemsWithUniqueForList(ctx context.Context, arg ItemsWithUniqueForListParams) ([]ItemsWithUniqueForListRow, error) {
	rows, err := q.db.QueryContext(ctx, itemsWithUniqueForList,
		arg.SiteID,
		arg.ListID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsWithUniqueForListRow
	for rows.Next() {
		var i ItemsWithUniqueForListRow
		if err := rows.Scan(
			&i.SiteID,
			&i.ItemGuid,
			&i.ListItemGuid,
			&i.ListID,
			&i.ItemID,
			&i.Url,
			&i.IsFile,
			&i.IsFolder,
			&i.HasUnique,
			&i.Name,
			&i.AuditRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const itemsWithUniqueForListByAuditRun = `-- name: ItemsWithUniqueForListByAuditRun :many
SELECT site_id, item_guid, list_item_guid, list_id, item_id, url, is_file, is_folder, has_unique, name, audit_run_id
FROM items
WHERE site_id = ?1 AND list_id = ?2 AND has_unique = 1 AND audit_run_id = ?3
ORDER BY item_id
LIMIT ?5 OFFSET ?4
`

type ItemsWithUniqueForListByAuditRunParams struct {
	SiteID     int64  `json:"site_id"`
	ListID     string `json:"list_id"`
	AuditRunID int64  `json:"audit_run_id"`
	Offset     int64  `json:"offset"`
	Limit      int64  `json:"limit"`
}

type ItemsWithUniqueForListByAuditRunRow struct {
	SiteID       int64          `json:"site_id"`
	ItemGuid     string         `json:"item_guid"`
	ListItemGuid sql.NullString `json:"list_item_guid"`
	ListID       string         `json:"list_id"`
	ItemID       int64          `json:"item_id"`
	Url          sql.NullString `json:"url"`
	IsFile       sql.NullBool   `json:"is_file"`
	IsFolder     sql.NullBool   `json:"is_folder"`
	HasUnique    sql.NullBool   `json:"has_unique"`
	Name         sql.NullString `json:"name"`
	AuditRunID   int64          `json:"audit_run_id"`
}

func (q *Queries) ItemsWithUniqueForListByAuditRun(ctx context.Context, arg ItemsWithUniqueForListByAuditRunParams) ([]ItemsWithUniqueForListByAuditRunRow, error) {
	rows, err := q.db.QueryContext(ctx, itemsWithUniqueForListByAuditRun,
		arg.SiteID,
		arg.ListID,
		arg.AuditRunID,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemsWithUniqueForListByAuditRunRow
	for rows.Next() {
		var i ItemsWithUniqueForListByAuditRunRow
		if err := rows.Scan(
			&i.SiteID,
			&i.ItemGuid,
			&i.ListItemGuid,
			&i.ListID,
			&i.ItemID,
			&i.Url,
			&i.IsFile,
			&i.IsFolder,
			&i.HasUnique,
			&i.Name,
			&i.AuditRunID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
