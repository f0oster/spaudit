// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: security.sql

package db

import (
	"context"
	"database/sql"
)

const deleteRoleAssignmentsForObject = `-- name: DeleteRoleAssignmentsForObject :exec
DELETE FROM role_assignments
WHERE site_id = ?1 AND object_type = ?2 AND object_key = ?3
`

type DeleteRoleAssignmentsForObjectParams struct {
	SiteID     int64  `json:"site_id"`
	ObjectType string `json:"object_type"`
	ObjectKey  string `json:"object_key"`
}

func (q *Queries) DeleteRoleAssignmentsForObject(ctx context.Context, arg DeleteRoleAssignmentsForObjectParams) error {
	_, err := q.db.ExecContext(ctx, deleteRoleAssignmentsForObject, arg.SiteID, arg.ObjectType, arg.ObjectKey)
	return err
}

const getAssignmentsForObjectByAuditRun = `-- name: GetAssignmentsForObjectByAuditRun :many
SELECT ra.principal_id, p.title AS principal_title, p.login_name, p.principal_type,
       ra.role_def_id, rd.name AS role_name, rd.description, ra.inherited
FROM role_assignments ra
JOIN principals p ON p.site_id = ra.site_id AND p.principal_id = ra.principal_id AND p.audit_run_id = ra.audit_run_id
JOIN role_definitions rd ON rd.site_id = ra.site_id AND rd.role_def_id = ra.role_def_id AND rd.audit_run_id = ra.audit_run_id
WHERE ra.site_id = ?1 AND ra.object_type = ?2 AND ra.object_key = ?3
  AND ra.audit_run_id = ?4
ORDER BY principal_title, role_name
`

type GetAssignmentsForObjectByAuditRunParams struct {
	SiteID     int64  `json:"site_id"`
	ObjectType string `json:"object_type"`
	ObjectKey  string `json:"object_key"`
	AuditRunID int64  `json:"audit_run_id"`
}

type GetAssignmentsForObjectByAuditRunRow struct {
	PrincipalID    int64          `json:"principal_id"`
	PrincipalTitle sql.NullString `json:"principal_title"`
	LoginName      sql.NullString `json:"login_name"`
	PrincipalType  int64          `json:"principal_type"`
	RoleDefID      int64          `json:"role_def_id"`
	RoleName       string         `json:"role_name"`
	Description    sql.NullString `json:"description"`
	Inherited      sql.NullBool   `json:"inherited"`
}

func (q *Queries) GetAssignmentsForObjectByAuditRun(ctx context.Context, arg GetAssignmentsForObjectByAuditRunParams) ([]GetAssignmentsForObjectByAuditRunRow, error) {
	rows, err := q.db.QueryContext(ctx, getAssignmentsForObjectByAuditRun,
		arg.SiteID,
		arg.ObjectType,
		arg.ObjectKey,
		arg.AuditRunID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAssignmentsForObjectByAuditRunRow
	for rows.Next() {
		var i GetAssignmentsForObjectByAuditRunRow
		if err := rows.Scan(
			&i.PrincipalID,
			&i.PrincipalTitle,
			&i.LoginName,
			&i.PrincipalType,
			&i.RoleDefID,
			&i.RoleName,
			&i.Description,
			&i.Inherited,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRootPermissionsForPrincipalInWebByAuditRun = `-- name: GetRootPermissionsForPrincipalInWebByAuditRun :many
SELECT ra.object_type, ra.object_key, rd.name as role_name,
       CASE ra.object_type
         WHEN 'list' THEN l.title
         WHEN 'web' THEN w.title
         WHEN 'item' THEN i.name
       END as object_name
FROM role_assignments ra
JOIN role_definitions rd ON ra.site_id = rd.site_id AND ra.role_def_id = rd.role_def_id AND rd.audit_run_id = ra.audit_run_id
LEFT JOIN lists l ON ra.object_type = 'list' AND ra.site_id = l.site_id AND ra.object_key = l.list_id AND l.web_id = ?1 AND l.audit_run_id = ra.audit_run_id
LEFT JOIN webs w ON ra.object_type = 'web' AND ra.site_id = w.site_id AND ra.object_key = w.web_id AND w.web_id = ?1 AND w.audit_run_id = ra.audit_run_id
LEFT JOIN items i ON ra.object_type = 'item' AND ra.site_id = i.site_id AND ra.object_key = i.item_guid AND i.audit_run_id = ra.audit_run_id
LEFT JOIN lists parent_list ON i.site_id = parent_list.site_id AND i.list_id = parent_list.list_id AND parent_list.web_id = ?1 AND parent_list.audit_run_id = ra.audit_run_id
WHERE ra.site_id = ?2 AND ra.principal_id = ?3 AND ra.audit_run_id = ?4
  AND rd.name NOT LIKE '%Limited%'
  AND (
    (ra.object_type = 'web' AND w.site_id = ?2 AND w.web_id = ?1)
    OR (ra.object_type = 'list' AND l.site_id = ?2 AND l.web_id = ?1)
    OR (ra.object_type = 'item' AND parent_list.site_id = ?2 AND parent_list.web_id = ?1)
  )
`

type GetRootPermissionsForPrincipalInWebByAuditRunParams struct {
	WebID       string `json:"web_id"`
	SiteID      int64  `json:"site_id"`
	PrincipalID int64  `json:"principal_id"`
	AuditRunID  int64  `json:"audit_run_id"`
}

type GetRootPermissionsForPrincipalInWebByAuditRunRow struct {
	ObjectType string      `json:"object_type"`
	ObjectKey  string      `json:"object_key"`
	RoleName   string      `json:"role_name"`
	ObjectName interface{} `json:"object_name"`
}

func (q *Queries) GetRootPermissionsForPrincipalInWebByAuditRun(ctx context.Context, arg GetRootPermissionsForPrincipalInWebByAuditRunParams) ([]GetRootPermissionsForPrincipalInWebByAuditRunRow, error) {
	rows, err := q.db.QueryContext(ctx, getRootPermissionsForPrincipalInWebByAuditRun,
		arg.WebID,
		arg.SiteID,
		arg.PrincipalID,
		arg.AuditRunID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRootPermissionsForPrincipalInWebByAuditRunRow
	for rows.Next() {
		var i GetRootPermissionsForPrincipalInWebByAuditRunRow
		if err := rows.Scan(
			&i.ObjectType,
			&i.ObjectKey,
			&i.RoleName,
			&i.ObjectName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedItemForSharingLink = `-- name: GetSharedItemForSharingLink :one
SELECT i.name as item_name, l.title as list_title
FROM sharing_links sl
LEFT JOIN items i ON sl.site_id = i.site_id AND sl.item_guid = i.item_guid
LEFT JOIN lists l ON i.site_id = l.site_id AND i.list_id = l.list_id
WHERE sl.site_id = ?1 AND sl.file_folder_unique_id = ?2
LIMIT 1
`

type GetSharedItemForSharingLinkParams struct {
	SiteID         int64          `json:"site_id"`
	FileFolderGuid sql.NullString `json:"file_folder_guid"`
}

type GetSharedItemForSharingLinkRow struct {
	ItemName  sql.NullString `json:"item_name"`
	ListTitle sql.NullString `json:"list_title"`
}

func (q *Queries) GetSharedItemForSharingLink(ctx context.Context, arg GetSharedItemForSharingLinkParams) (GetSharedItemForSharingLinkRow, error) {
	row := q.db.QueryRowContext(ctx, getSharedItemForSharingLink, arg.SiteID, arg.FileFolderGuid)
	var i GetSharedItemForSharingLinkRow
	err := row.Scan(&i.ItemName, &i.ListTitle)
	return i, err
}

const getWebIdForObject = `-- name: GetWebIdForObject :one
SELECT 
  CASE ?1
    WHEN 'web' THEN ?2
    WHEN 'list' THEN l.web_id
    WHEN 'item' THEN parent_list.web_id
  END as web_id
FROM (SELECT 1 as dummy) d
LEFT JOIN lists l ON ?1 = 'list' AND ?3 = l.site_id AND ?2 = l.list_id
LEFT JOIN items i ON ?1 = 'item' AND ?3 = i.site_id AND ?2 = i.item_guid
LEFT JOIN lists parent_list ON i.site_id = parent_list.site_id AND i.list_id = parent_list.list_id
LIMIT 1
`

type GetWebIdForObjectParams struct {
	ObjectType string `json:"object_type"`
	ObjectKey  string `json:"object_key"`
	SiteID     int64  `json:"site_id"`
}

func (q *Queries) GetWebIdForObject(ctx context.Context, arg GetWebIdForObjectParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getWebIdForObject, arg.ObjectType, arg.ObjectKey, arg.SiteID)
	var web_id interface{}
	err := row.Scan(&web_id)
	return web_id, err
}

const insertPrincipal = `-- name: InsertPrincipal :exec
INSERT INTO principals (site_id, principal_id, principal_type, title, login_name, email, audit_run_id)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
`

type InsertPrincipalParams struct {
	SiteID        int64          `json:"site_id"`
	PrincipalID   int64          `json:"principal_id"`
	PrincipalType int64          `json:"principal_type"`
	Title         sql.NullString `json:"title"`
	LoginName     sql.NullString `json:"login_name"`
	Email         sql.NullString `json:"email"`
	AuditRunID    int64          `json:"audit_run_id"`
}

func (q *Queries) InsertPrincipal(ctx context.Context, arg InsertPrincipalParams) error {
	_, err := q.db.ExecContext(ctx, insertPrincipal,
		arg.SiteID,
		arg.PrincipalID,
		arg.PrincipalType,
		arg.Title,
		arg.LoginName,
		arg.Email,
		arg.AuditRunID,
	)
	return err
}

const insertRoleAssignment = `-- name: InsertRoleAssignment :exec
INSERT INTO role_assignments (site_id, object_type, object_key, principal_id, role_def_id, inherited, audit_run_id)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
`

type InsertRoleAssignmentParams struct {
	SiteID      int64        `json:"site_id"`
	ObjectType  string       `json:"object_type"`
	ObjectKey   string       `json:"object_key"`
	PrincipalID int64        `json:"principal_id"`
	RoleDefID   int64        `json:"role_def_id"`
	Inherited   sql.NullBool `json:"inherited"`
	AuditRunID  int64        `json:"audit_run_id"`
}

func (q *Queries) InsertRoleAssignment(ctx context.Context, arg InsertRoleAssignmentParams) error {
	_, err := q.db.ExecContext(ctx, insertRoleAssignment,
		arg.SiteID,
		arg.ObjectType,
		arg.ObjectKey,
		arg.PrincipalID,
		arg.RoleDefID,
		arg.Inherited,
		arg.AuditRunID,
	)
	return err
}

const insertRoleDefinition = `-- name: InsertRoleDefinition :exec
INSERT INTO role_definitions (site_id, role_def_id, name, description, audit_run_id)
VALUES (?1, ?2, ?3, ?4, ?5)
`

type InsertRoleDefinitionParams struct {
	SiteID      int64          `json:"site_id"`
	RoleDefID   int64          `json:"role_def_id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	AuditRunID  int64          `json:"audit_run_id"`
}

func (q *Queries) InsertRoleDefinition(ctx context.Context, arg InsertRoleDefinitionParams) error {
	_, err := q.db.ExecContext(ctx, insertRoleDefinition,
		arg.SiteID,
		arg.RoleDefID,
		arg.Name,
		arg.Description,
		arg.AuditRunID,
	)
	return err
}

const upsertPrincipalByLogin = `-- name: UpsertPrincipalByLogin :one
INSERT INTO principals (site_id, principal_type, title, login_name, email)
VALUES (?1, ?2, ?3, ?4, ?5)
ON CONFLICT(site_id, login_name) DO UPDATE SET
  principal_type = excluded.principal_type,
  title          = COALESCE(excluded.title, principals.title),
  email          = COALESCE(excluded.email, principals.email)
RETURNING principal_id
`

type UpsertPrincipalByLoginParams struct {
	SiteID        int64          `json:"site_id"`
	PrincipalType int64          `json:"principal_type"`
	Title         sql.NullString `json:"title"`
	LoginName     sql.NullString `json:"login_name"`
	Email         sql.NullString `json:"email"`
}

func (q *Queries) UpsertPrincipalByLogin(ctx context.Context, arg UpsertPrincipalByLoginParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertPrincipalByLogin,
		arg.SiteID,
		arg.PrincipalType,
		arg.Title,
		arg.LoginName,
		arg.Email,
	)
	var principal_id int64
	err := row.Scan(&principal_id)
	return principal_id, err
}
